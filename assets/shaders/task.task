#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require

// Task shader for GPU-driven culling and meshlet dispatch
// Optimized for VK_KHR_shader_maximal_reconvergence

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Input structures
struct GpuDrawCommand {
    uint meshlet_offset;
    uint meshlet_count;
    uint instance_count;
    uint first_instance;
};

struct GpuMeshlet {
    uint vertex_offset;
    uint vertex_count;
    uint primitive_offset;
    uint primitive_count;
    vec3 center;
    float radius;
    vec3 cone_axis;
    float cone_cutoff;
};

// Storage buffers
layout(set = 0, binding = 0) readonly buffer DrawCommandBuffer {
    GpuDrawCommand draw_commands[];
};

layout(set = 0, binding = 1) readonly buffer MeshletBuffer {
    GpuMeshlet meshlets[];
};

// Uniform buffer for culling data
layout(set = 0, binding = 2) uniform CullingData {
    mat4 view_proj;
    vec4 frustum_planes[6]; // Left, Right, Bottom, Top, Near, Far
    vec3 camera_pos;
    float lod_bias;
    vec2 viewport_size;
    float near_plane;
    float far_plane;
} culling;

// Task payload to pass data to mesh shader
struct TaskPayload {
    uint meshlet_indices[32]; // Up to 32 meshlets per workgroup
    uint visible_count;
};

taskPayloadSharedEXT TaskPayload payload;

// Frustum culling function optimized for maximal reconvergence
bool is_meshlet_visible(uint meshlet_index) {
    // Get meshlet data
    GpuMeshlet meshlet = meshlets[meshlet_index];
    
    vec3 meshlet_center = meshlet.center;
    float meshlet_radius = meshlet.radius;
    
    // Early exit for degenerate meshlets
    if (meshlet.vertex_count == 0 || meshlet.primitive_count == 0) {
        return false;
    }
    
    // Distance-based LOD culling with branching that benefits from reconvergence
    float distance_to_camera = length(culling.camera_pos - meshlet_center);
    float lod_threshold = culling.lod_bias * 100.0; // Adjust based on needs
    
    // Threads with similar distances will reconverge after this branch
    if (distance_to_camera > lod_threshold) {
        return false; // Too far for current LOD
    }
    
    // Frustum culling against all 6 planes
    // Threads processing nearby meshlets will likely have similar results
    for (int i = 0; i < 6; i++) {
        vec4 plane = culling.frustum_planes[i];
        float distance_to_plane = dot(plane.xyz, meshlet_center) + plane.w;
        
        // If meshlet is completely outside this plane, it's not visible
        if (distance_to_plane < -meshlet_radius) {
            return false;
        }
    }
    
    // Near/far plane culling
    if (distance_to_camera < culling.near_plane - meshlet_radius || distance_to_camera > culling.far_plane + meshlet_radius) {
        return false;
    }
    
    // Backface culling for meshlets (simplified)
    // Uses cone culling if available (cone_cutoff > 0)
    // Currently placeholder as cone_cutoff is 0 in generation
    if (meshlet.cone_cutoff > 0.0) {
        vec3 view_dir = normalize(culling.camera_pos - meshlet_center);
        if (dot(view_dir, meshlet.cone_axis) < meshlet.cone_cutoff) {
             return false;
        }
    }
    
    return true;
}

void main() {
    uint dt_id = gl_GlobalInvocationID.x;
    
    // Assume one draw command for now (index 0)
    // In robust implementation, use draw_id or push constants
    uint meshlet_count = draw_commands[0].meshlet_count;
    
    if (dt_id >= meshlet_count) return;
    
    uint meshlet_index = draw_commands[0].meshlet_offset + dt_id;
    bool visible = is_meshlet_visible(meshlet_index);
    
    // Subgroup ballot to collect visible meshlets
    uvec4 ballot = subgroupBallot(visible);
    uint visible_count_subgroup = subgroupBallotBitCount(ballot);
    uint index_in_subgroup = subgroupBallotExclusiveBitCount(ballot);
    
    if (visible) {
        payload.meshlet_indices[index_in_subgroup] = meshlet_index;
    }
    
    if (gl_LocalInvocationID.x == 0) {
        payload.visible_count = visible_count_subgroup;
        EmitMeshTasksEXT(visible_count_subgroup, 1, 1);
    }
}
