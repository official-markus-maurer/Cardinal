#version 450
#extension GL_EXT_mesh_shader : require
#extension GL_KHR_shader_subgroup_ballot : require

// Task shader for GPU-driven culling and meshlet dispatch
// Optimized for VK_KHR_shader_maximal_reconvergence:
// - Threads processing spatially coherent meshlets will have similar culling results
// - Branching patterns in frustum/LOD culling benefit from maximal reconvergence
// - Reduces divergence when threads take different paths through culling logic

layout(local_size_x = 32, local_size_y = 1, local_size_z = 1) in;

// Input structures
struct GpuDrawCommand {
    uint meshlet_offset;
    uint meshlet_count;
    uint instance_count;
    uint first_instance;
};

struct GpuMeshlet {
    uint vertex_offset;
    uint vertex_count;
    uint primitive_offset;
    uint primitive_count;
};

// Storage buffers
layout(set = 0, binding = 0) readonly buffer DrawCommandBuffer {
    GpuDrawCommand draw_commands[];
};

layout(set = 0, binding = 1) readonly buffer MeshletBuffer {
    GpuMeshlet meshlets[];
};

// Uniform buffer for culling data
layout(set = 0, binding = 2) uniform CullingData {
    mat4 view_proj;
    vec4 frustum_planes[6]; // Left, Right, Bottom, Top, Near, Far
    vec3 camera_pos;
    float lod_bias;
    vec2 viewport_size;
    float near_plane;
    float far_plane;
} culling;

// Task payload to pass data to mesh shader
struct TaskPayload {
    uint meshlet_indices[32]; // Up to 32 meshlets per workgroup
    uint visible_count;
};

taskPayloadSharedEXT TaskPayload payload;

// Frustum culling function optimized for maximal reconvergence
bool is_meshlet_visible(uint meshlet_index) {
    // Get meshlet data
    GpuMeshlet meshlet = meshlets[meshlet_index];
    
    // Calculate meshlet bounding sphere center (simplified)
    // In a real implementation, this would be precomputed and stored
    vec3 meshlet_center = vec3(0.0); // Placeholder - would be actual center
    float meshlet_radius = 1.0; // Placeholder - would be actual radius
    
    // Early exit for degenerate meshlets
    if (meshlet.vertex_count == 0 || meshlet.primitive_count == 0) {
        return false;
    }
    
    // Distance-based LOD culling with branching that benefits from reconvergence
    float distance_to_camera = length(culling.camera_pos - meshlet_center);
    float lod_threshold = culling.lod_bias * 100.0; // Adjust based on needs
    
    // Threads with similar distances will reconverge after this branch
    if (distance_to_camera > lod_threshold) {
        return false; // Too far for current LOD
    }
    
    // Frustum culling against all 6 planes
    // Threads processing nearby meshlets will likely have similar results
    for (int i = 0; i < 6; i++) {
        vec4 plane = culling.frustum_planes[i];
        float distance_to_plane = dot(plane.xyz, meshlet_center) + plane.w;
        
        // If meshlet is completely outside this plane, it's not visible
        if (distance_to_plane < -meshlet_radius) {
            return false;
        }
    }
    
    // Additional culling tests that benefit from reconvergence
    // Near/far plane culling
    if (distance_to_camera < culling.near_plane || distance_to_camera > culling.far_plane) {
        return false;
    }
    
    // Backface culling for meshlets (simplified)
    vec3 view_dir = normalize(culling.camera_pos - meshlet_center);
    // In a real implementation, you'd use the meshlet's normal cone
    
    return true;
}

// Distance-based LOD calculation
float calculate_lod(vec3 meshlet_center) {
    float distance = length(culling.camera_pos - meshlet_center);
    return distance * culling.lod_bias;
}

void main() {
    uint thread_id = gl_LocalInvocationID.x;
    uint group_id = gl_WorkGroupID.x;
    
    // Initialize payload
    if (thread_id == 0) {
        payload.visible_count = 0;
    }
    
    barrier();
    
    // Bounds check for draw commands
    if (group_id >= draw_commands.length()) {
        return;
    }
    
    GpuDrawCommand draw_cmd = draw_commands[group_id];
    
    // Process meshlets in this draw command
    // Organize work to maximize spatial coherence for better reconvergence
    uint meshlets_per_thread = (draw_cmd.meshlet_count + 31) / 32; // Round up
    
    // Process meshlets in spatially coherent groups to benefit from maximal reconvergence
    for (uint i = 0; i < meshlets_per_thread; i++) {
        uint meshlet_local_index = thread_id + i * 32;
        
        if (meshlet_local_index < draw_cmd.meshlet_count) {
            uint meshlet_global_index = draw_cmd.meshlet_offset + meshlet_local_index;
            
            // Bounds check for meshlets
            if (meshlet_global_index < meshlets.length()) {
                // Perform culling tests - threads processing nearby meshlets
                // will likely have similar results, benefiting from reconvergence
                bool is_visible = is_meshlet_visible(meshlet_global_index);
                
                // Use ballot to check how many threads in the warp passed culling
                // This helps with divergence analysis and can guide future optimizations
                uvec4 visibility_mask = subgroupBallot(is_visible);
                
                if (is_visible) {
                    // Add to visible list (atomic operation)
                    uint visible_index = atomicAdd(payload.visible_count, 1);
                    
                    if (visible_index < 32) { // Limit to payload size
                        payload.meshlet_indices[visible_index] = meshlet_global_index;
                    }
                }
            }
        }
    }
    
    barrier();
    
    // Dispatch mesh shader workgroups for visible meshlets
    if (thread_id == 0) {
        uint mesh_workgroups = min(payload.visible_count, 32);
        EmitMeshTasksEXT(mesh_workgroups, 1, 1);
    }
}